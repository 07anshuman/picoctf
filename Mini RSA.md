# Mini RSA challenge 
## **Flag**: picoCTF{e_sh0u1d_b3_lArg3r_6e2e6bda}

So this is the other Mini RSA challenge different from miniRSA, I actually first set out to do this because it was 'medium' level and the other was 'hard'. But I only solved it after I did that one, I thought the same logic and code would work for this but it didn't.  

I tried several iterations, went as up in running the loop for k value as 100,000 but it did not find the perfect root, actually it failed to satisfy the `M^e==candidate` check in the code. Using chatGPT and the hint `Make sure you don't lose precision, the numbers are pretty big (besides the e value)` I understood it had to do with how `Integer(...).nth_root(e))` computes the e-th root, it finds a value very close and assumes it to be a perfect root but because of this when the code performs `M^e==candidate` check, it fails. 
It probably worked for miniRSA since the k value needed in that case was 0, and so M was equal to C 

`numpy` didn't work either, chatGPT suggest `gmpy2` with the same logic of code as mini RSA but implemented in python using gmpy2 instead of Sage with its `nth_root(e)` function.

```
import gmpy2

N = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
C = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962
e = 3

for k in range(10000):  #so this is what pico meant by `too few` trickster mofos
    candidate = k * N + C
    
    m, is_true_root = gmpy2.iroot(candidate, e)
    
    if is_true_root:
        print(f"Found k = {k}, M = {m}")
      
        hex_code = hex(m)[2:] 
        
        try:
            plaintext = bytes.fromhex(hex_code).decode('utf-8')
            print(f"Message: {plaintext}")
        except ValueError:
            print("Error decoding the message")
        break
```
And voila! It worked!

Output:
```
Found k = 3533, M = 1787330808968142828287809319332701517353332911736848279839502759158602467824780424488141955644417387373185756944952906538004355347478978500948630620749868180414755933760446136287315896825929319145984883756667607031853695069891380871892213007874933611243319812691520078269033745367443951846845107464675742664639073699911281377201069777277
Message:                                                                                                         picoCTF{e_sh0u1d_b3_lArg3r_6e2e6bda}
```
As we see in the output it is actually padded and pico starts not at the beginning. 
This one was actually a better challenge than miniRSA since it had precision issues and larger exponents to deal with. Learnt a lot honestly. 
